// Package websocket_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package websocket_api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	. "github.com/kurtosis-tech/kurtosis/api/golang/http_rest/api_types"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get enclave's services logs
	// (GET /enclaves/{enclave_identifier}/logs)
	GetEnclavesEnclaveIdentifierLogs(ctx echo.Context, enclaveIdentifier EnclaveIdentifier, params GetEnclavesEnclaveIdentifierLogsParams) error
	// Get service logs
	// (GET /enclaves/{enclave_identifier}/services/{service_identifier}/logs)
	GetEnclavesEnclaveIdentifierServicesServiceIdentifierLogs(ctx echo.Context, enclaveIdentifier EnclaveIdentifier, serviceIdentifier ServiceIdentifier, params GetEnclavesEnclaveIdentifierServicesServiceIdentifierLogsParams) error
	// Get Starlark execution logs
	// (GET /starlark/executions/{starlark_execution_uuid}/logs)
	GetStarlarkExecutionsStarlarkExecutionUuidLogs(ctx echo.Context, starlarkExecutionUuid StarlarkExecutionUuid) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetEnclavesEnclaveIdentifierLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetEnclavesEnclaveIdentifierLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "enclave_identifier" -------------
	var enclaveIdentifier EnclaveIdentifier

	err = runtime.BindStyledParameterWithLocation("simple", false, "enclave_identifier", runtime.ParamLocationPath, ctx.Param("enclave_identifier"), &enclaveIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter enclave_identifier: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEnclavesEnclaveIdentifierLogsParams
	// ------------- Required query parameter "service_uuid_set" -------------

	err = runtime.BindQueryParameter("form", true, true, "service_uuid_set", ctx.QueryParams(), &params.ServiceUuidSet)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_uuid_set: %s", err))
	}

	// ------------- Optional query parameter "follow_logs" -------------

	err = runtime.BindQueryParameter("form", true, false, "follow_logs", ctx.QueryParams(), &params.FollowLogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter follow_logs: %s", err))
	}

	// ------------- Optional query parameter "conjunctive_filters" -------------

	err = runtime.BindQueryParameter("form", true, false, "conjunctive_filters", ctx.QueryParams(), &params.ConjunctiveFilters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter conjunctive_filters: %s", err))
	}

	// ------------- Optional query parameter "return_all_logs" -------------

	err = runtime.BindQueryParameter("form", true, false, "return_all_logs", ctx.QueryParams(), &params.ReturnAllLogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter return_all_logs: %s", err))
	}

	// ------------- Optional query parameter "num_log_lines" -------------

	err = runtime.BindQueryParameter("form", true, false, "num_log_lines", ctx.QueryParams(), &params.NumLogLines)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num_log_lines: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEnclavesEnclaveIdentifierLogs(ctx, enclaveIdentifier, params)
	return err
}

// GetEnclavesEnclaveIdentifierServicesServiceIdentifierLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetEnclavesEnclaveIdentifierServicesServiceIdentifierLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "enclave_identifier" -------------
	var enclaveIdentifier EnclaveIdentifier

	err = runtime.BindStyledParameterWithLocation("simple", false, "enclave_identifier", runtime.ParamLocationPath, ctx.Param("enclave_identifier"), &enclaveIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter enclave_identifier: %s", err))
	}

	// ------------- Path parameter "service_identifier" -------------
	var serviceIdentifier ServiceIdentifier

	err = runtime.BindStyledParameterWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, ctx.Param("service_identifier"), &serviceIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_identifier: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEnclavesEnclaveIdentifierServicesServiceIdentifierLogsParams
	// ------------- Optional query parameter "follow_logs" -------------

	err = runtime.BindQueryParameter("form", true, false, "follow_logs", ctx.QueryParams(), &params.FollowLogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter follow_logs: %s", err))
	}

	// ------------- Optional query parameter "conjunctive_filters" -------------

	err = runtime.BindQueryParameter("form", true, false, "conjunctive_filters", ctx.QueryParams(), &params.ConjunctiveFilters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter conjunctive_filters: %s", err))
	}

	// ------------- Optional query parameter "return_all_logs" -------------

	err = runtime.BindQueryParameter("form", true, false, "return_all_logs", ctx.QueryParams(), &params.ReturnAllLogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter return_all_logs: %s", err))
	}

	// ------------- Optional query parameter "num_log_lines" -------------

	err = runtime.BindQueryParameter("form", true, false, "num_log_lines", ctx.QueryParams(), &params.NumLogLines)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter num_log_lines: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEnclavesEnclaveIdentifierServicesServiceIdentifierLogs(ctx, enclaveIdentifier, serviceIdentifier, params)
	return err
}

// GetStarlarkExecutionsStarlarkExecutionUuidLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetStarlarkExecutionsStarlarkExecutionUuidLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "starlark_execution_uuid" -------------
	var starlarkExecutionUuid StarlarkExecutionUuid

	err = runtime.BindStyledParameterWithLocation("simple", false, "starlark_execution_uuid", runtime.ParamLocationPath, ctx.Param("starlark_execution_uuid"), &starlarkExecutionUuid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter starlark_execution_uuid: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStarlarkExecutionsStarlarkExecutionUuidLogs(ctx, starlarkExecutionUuid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/enclaves/:enclave_identifier/logs", wrapper.GetEnclavesEnclaveIdentifierLogs)
	router.GET(baseURL+"/enclaves/:enclave_identifier/services/:service_identifier/logs", wrapper.GetEnclavesEnclaveIdentifierServicesServiceIdentifierLogs)
	router.GET(baseURL+"/starlark/executions/:starlark_execution_uuid/logs", wrapper.GetStarlarkExecutionsStarlarkExecutionUuidLogs)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
